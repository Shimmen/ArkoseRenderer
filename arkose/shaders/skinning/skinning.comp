#version 460

#extension GL_EXT_scalar_block_layout : require

#include <common.glsl>
#include <common/namedUniforms.glsl>
#include <shared/SceneData.h>

layout(set = 0, binding = 0, scalar) buffer restrict PositionVertexBlock { vec3 positions[]; };
layout(set = 0, binding = 1, scalar) buffer restrict VelocityVertexBlock { vec3 velocities[]; };
layout(set = 0, binding = 2, scalar) buffer restrict NonPositionVertexBlock { NonPositionVertex nonPositionVertexData[]; };
layout(set = 0, binding = 3, scalar) buffer restrict readonly SkinningVertexBlock { SkinningVertex skinningVertexData[]; };
layout(set = 0, binding = 4, scalar) buffer restrict readonly MorphTargetVertexBlock { MorphTargetVertex morphTargetVertexData[]; };
layout(set = 0, binding = 5) buffer restrict readonly JointMatricesBlock { mat4 jointMatrices[]; };
layout(set = 0, binding = 6) buffer restrict readonly MorphTargetMetaBlock { vec2 morphTargetMetadata[]; };

NAMED_UNIFORMS(constants,
    uint firstSrcVertexIdx;
    uint firstDstVertexIdx;
    int  firstSkinningVertexIdx;
    uint firstVelocityVertexIdx;
    uint vertexCount;
    uint morphTargetCount;
)

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;
void main()
{
    uint localVertexIdx = gl_GlobalInvocationID.x;
    if (localVertexIdx >= constants.vertexCount) {
        return;
    }

    // Read in source vertex data

    uint srcVertexIdx = constants.firstSrcVertexIdx + localVertexIdx;

    vec3 originalPosition = positions[srcVertexIdx];
    vec3 position = originalPosition;

    NonPositionVertex vertex = nonPositionVertexData[srcVertexIdx];

    // Do morph target blending

    if (constants.morphTargetCount > 0) {

        for (uint idx = 0; idx < constants.morphTargetCount; ++idx) {
            vec2 morphTargetMeta = morphTargetMetadata[idx];

            uint morphVertexIdx = uint(morphTargetMeta.x) + localVertexIdx;
            MorphTargetVertex morphTargetVertex = morphTargetVertexData[morphVertexIdx];

            float morphTargetWeight = morphTargetMeta.y;
            position += morphTargetVertex.position * morphTargetWeight;
            vertex.normal += morphTargetVertex.normal * morphTargetWeight;
            vertex.tangent.xyz += morphTargetVertex.tangent * morphTargetWeight;
        }

        // Re-normalize & re-orthogonalize normals and tangents
        vertex.normal = normalize(vertex.normal);
        vertex.tangent.xyz = normalize(vertex.tangent.xyz);
        vertex.tangent.xyz = normalize(vertex.tangent.xyz - vertex.normal * dot(vertex.normal, vertex.tangent.xyz));

    }

    // Do skeletal/skinned animation

    if (constants.firstSkinningVertexIdx >= 0) {

        uint jointVertexIdx = constants.firstSkinningVertexIdx + localVertexIdx;
        SkinningVertex skinningVertex = skinningVertexData[jointVertexIdx];

        mat4 animatedFromLocal = jointMatrices[skinningVertex.jointIndices.x] * skinningVertex.jointWeights.x +
                                 jointMatrices[skinningVertex.jointIndices.y] * skinningVertex.jointWeights.y +
                                 jointMatrices[skinningVertex.jointIndices.z] * skinningVertex.jointWeights.z +
                                 jointMatrices[skinningVertex.jointIndices.w] * skinningVertex.jointWeights.w;

        position = vec3(animatedFromLocal * vec4(position, 1.0));

        mat3 animatedFromTangent = transpose(inverse(mat3(animatedFromLocal)));
        vertex.normal = animatedFromTangent * vertex.normal;
        vertex.tangent.xyz = animatedFromTangent * vertex.tangent.xyz;

    }

    // Write out morphed & skinned data

    uint dstVertexIdx = constants.firstDstVertexIdx + localVertexIdx;

    positions[dstVertexIdx] = position;
    nonPositionVertexData[dstVertexIdx] = vertex;

    uint dstVelocityVertexIdx = constants.firstVelocityVertexIdx + localVertexIdx;
    velocities[dstVelocityVertexIdx] = position - originalPosition;
}
