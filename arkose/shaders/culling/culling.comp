#version 460

#include <common.glsl>
#include <common/namedUniforms.glsl>
#include <shared/IndirectData.h>
#include <shared/SceneData.h>
#include <shared/ShaderBlendMode.h>

layout(set = 0, binding = 0) readonly buffer CameraFrustums { vec4 frustumPlanes[6]; };
layout(set = 0, binding = 1) readonly buffer InObjectData   { IndirectShaderDrawable inputDrawables[]; };

layout(set = 0, binding = 2) writeonly buffer OpaqueDrawables { ShaderDrawable opaqueDrawables[]; };
layout(set = 0, binding = 3) writeonly buffer OpauqeDrawCmds  { IndexedDrawCmd opaqueDrawCmds[]; };
layout(set = 0, binding = 4)           buffer OpauqeCount     { uint opaqueCount; };

layout(set = 0, binding = 5) writeonly buffer MaskedDrawables { ShaderDrawable maskedDrawables[]; };
layout(set = 0, binding = 6) writeonly buffer MaskedDrawCmds  { IndexedDrawCmd maskedDrawCmds[]; };
layout(set = 0, binding = 7)           buffer MaskedCount     { uint maskedCount; };

NAMED_UNIFORMS(constants,
    bool frustumCull;
    uint numInputDrawables;
)

bool sphereIsIncludedInFrustum(vec4 sphere)
{
    bool isIncluded = true;
    for (int i = 0; i < 6; ++i) {
        float signedDist = dot(frustumPlanes[i].xyz, sphere.xyz) + frustumPlanes[i].w;
        if (signedDist > sphere.w)
            isIncluded = false;
    }
    return isIncluded;
}

layout(local_size_x = 64, local_size_y = 1) in;
void main()
{
    const uint objectIdx = gl_GlobalInvocationID.x;
    if (objectIdx >= constants.numInputDrawables)
        return;

    IndirectShaderDrawable inputDrawable = inputDrawables[objectIdx];

    mat4 transform = inputDrawable.drawable.worldFromLocal;
    vec4 transformedSphere = transformSphere(inputDrawable.localBoundingSphere, transform);
    if (constants.frustumCull && !sphereIsIncludedInFrustum(transformedSphere))
        return;

    IndexedDrawCmd cmd;
    cmd.indexCount = inputDrawable.indexCount;
    cmd.firstIndex = inputDrawable.firstIndex;
    cmd.vertexOffset = inputDrawable.vertexOffset;
    cmd.firstInstance = 0;
    cmd.instanceCount = 1;

    switch (inputDrawable.materialBlendMode) {

        case BLEND_MODE_OPAQUE: {
            uint idx = atomicAdd(opaqueCount, 1u);
            opaqueDrawables[idx] = inputDrawable.drawable;
            opaqueDrawCmds[idx] = cmd;
            break;
        }

        case BLEND_MODE_MASKED: {
            uint idx = atomicAdd(maskedCount, 1u);
            maskedDrawables[idx] = inputDrawable.drawable;
            maskedDrawCmds[idx] = cmd;
            break;
        }

        case BLEND_MODE_TRANSLUCENT: {
            // TODO: Handle translucents (including sorting?) (or let it be CPU based for now)
            break;
        }
    }
}
