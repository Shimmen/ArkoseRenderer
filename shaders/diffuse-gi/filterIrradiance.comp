#version 460

#include <common.glsl>
#include <common/random.glsl>
#include <common/sh.glsl>
#include <common/spherical.glsl>
#include <shared/ProbeDebug.h>

layout(set = 0, binding = 0, rgba16f) uniform writeonly image2D     irradianceShImg;
layout(set = 0, binding = 1)          uniform           samplerCube radianceCube;
layout(set = 0, binding = 2)          uniform           sampler2D   skyViewTex;

layout(push_constant) uniform PushConstants {
    float environmentMultiplier;
    uint frameIndex;
};

float areaElement(float x, float y)
{
    return atan(x * y, sqrt(x * x + y * y + 1.0));
}

float texelCoordSolidAngle(vec2 uv, int cubeFaceSize)
{
   //scale up to [-1, 1] range (inclusive), offset by 0.5 to point to texel center.
   float U = 2.0 * uv.x - 1.0;
   float V = 2.0 * uv.y - 1.0;

   float invResolution = 1.0 / cubeFaceSize;

    // U and V are the -1..1 texture coordinate on the current face.
    // Get projected area for this texel
    float x0 = U - invResolution;
    float y0 = V - invResolution;
    float x1 = U + invResolution;
    float y1 = V + invResolution;
    float solidAngle = areaElement(x0, y0) - areaElement(x0, y1) - areaElement(x1, y0) + areaElement(x1, y1);

    return solidAngle;
}

vec2 cubemapFaceUV(vec3 direction)
{
    // NOTE: I'm pretty sure this is very wrong but it should suffice for calculating cubemap texel solid angles

    float x = abs(direction.x);
    float y = abs(direction.y);
    float z = abs(direction.z);

    if (x > y && x > z) {
        // face is +x or -x
        return vec2(y, z);
    } else if (y > x && y > z) {
        // face is +y or -y
        return vec2(x, z);
    } else {
        // face is +z or -z (or something undefined)
        return vec2(x, y);
    }
}

vec3 sampleRadianceInDirection(vec3 direction, out float weight)
{
    vec4 radianceFull = texture(radianceCube, direction);
    vec3 radiance = radianceFull.rgb;

    // TODO: Cubemap solid angles should go here!! Well, at least a relative solid angle in [0, 1]
    //  Something based on this: http://www.rorydriscoll.com/2012/01/15/cubemap-texel-solid-angle/
    weight = texelCoordSolidAngle(cubemapFaceUV(direction), 1);

    // TODO: It probably be faster if we didn't sample the sky-view here.
    //  We should probably put it in the cube texture to begin with..
    if (radianceFull.a < 1e-2f) {
        const vec3 skyViewDirection = vec3(direction.x, -direction.y, direction.z);
        vec2 sampleUv = sphericalUvFromDirection(skyViewDirection);
        const float refSolidAngleCheat = 1.0;
        weight = sphericalMappingPixelSolidAngle(skyViewDirection, refSolidAngleCheat);
        radiance += environmentMultiplier * texture(skyViewTex, sampleUv).rgb;
    }

    radiance *= weight;
    return radiance;
}

SHVectorRGB mapCubemapToSphericalHarmonics()
{
    const int numSamples = 4096;

    SHVectorRGB sh = createSphericalHarmonicsZeroRGB();
    float weight = 0.0;

    for (int i = 0; i < numSamples; ++i) {

        vec3 rayDirection = randomPointOnSphere();
        SHVector basis = createSphericalHarmonicsBasis(rayDirection);

        float sampleWeight;
        vec3 L = sampleRadianceInDirection(rayDirection, sampleWeight);

        sh.e00  += L * basis.e00;
        sh.e11  += L * basis.e11;
        sh.e10  += L * basis.e10;
        sh.e1_1 += L * basis.e1_1;
        sh.e21  += L * basis.e21;
        sh.e2_1 += L * basis.e2_1;
        sh.e2_2 += L * basis.e2_2;
        sh.e20  += L * basis.e20;
        sh.e22  += L * basis.e22;

        weight += sampleWeight;
    }

    // Hmmm..
    sh.e00  /= weight;
    sh.e11  /= weight;
    sh.e10  /= weight;
    sh.e1_1 /= weight;
    sh.e21  /= weight;
    sh.e2_1 /= weight;
    sh.e2_2 /= weight;
    sh.e20  /= weight;
    sh.e22  /= weight;

    return sh;
}

// TODO: We could probably do this in parallel some more and merge in the end?
layout(local_size_x = 1, local_size_y = 1) in;
void main()
{
    uint seed = frameIndex;
    seedRandom(seed);

    SHVectorRGB sh = mapCubemapToSphericalHarmonics();

    // Can't seem to pass my image.. so I inlined it here
    //storeSphericalHarmonicsRGB(sh, irradianceShImg);
    imageStore(irradianceShImg, ivec2(0,0), vec4(sh.e00,  0.0));
    imageStore(irradianceShImg, ivec2(1,0), vec4(sh.e11,  0.0));
    imageStore(irradianceShImg, ivec2(2,0), vec4(sh.e10,  0.0));
    imageStore(irradianceShImg, ivec2(0,1), vec4(sh.e1_1, 0.0));
    imageStore(irradianceShImg, ivec2(1,1), vec4(sh.e21,  0.0));
    imageStore(irradianceShImg, ivec2(2,1), vec4(sh.e2_1, 0.0));
    imageStore(irradianceShImg, ivec2(0,2), vec4(sh.e2_2, 0.0));
    imageStore(irradianceShImg, ivec2(1,2), vec4(sh.e20,  0.0));
    imageStore(irradianceShImg, ivec2(2,2), vec4(sh.e22,  0.0));
}
