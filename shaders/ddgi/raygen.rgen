#version 460
#extension GL_NV_ray_tracing : require

#include <common/namedUniforms.glsl>
#include <common/spherical.glsl>
#include <ddgi/common.glsl>
#include <shared/CameraState.h>

layout(set = 0, binding = 0) uniform accelerationStructureNV topLevelAS;
layout(set = 0, binding = 1) uniform CameraStateBlock { CameraState camera; };
layout(set = 0, binding = 2) uniform GridDataBlock { DDGIProbeGridData probeGridData; };
layout(set = 0, binding = 3) uniform sampler2D environmentMap;
layout(set = 0, binding = 4, rgba16f) uniform image2D surfelImage;

NAMED_UNIFORMS_STRUCT(RayTracingPushConstants, pushConstants)

layout(location = 0) rayPayloadNV RayPayload payload;

struct HitResult {
    vec3 color;
    float dist;
};

HitResult tracePrimaryRay(vec3 origin, vec3 direction)
{
    float tmin = camera.near;
    float tmax = camera.far;

    int numHits = 0;
    vec3 color = vec3(0.0);

    // Opaque
    {
        uint rayFlags = gl_RayFlagsOpaqueNV | gl_RayFlagsCullBackFacingTrianglesNV;
        uint cullMask = RT_HIT_MASK_OPAQUE;

        traceNV(topLevelAS, rayFlags, cullMask, 0, 0, 0, origin, tmin, direction, tmax, 0);
        if (payload.hitT != HIT_T_MISS) {
            tmax = payload.hitT;
            color = payload.color;
            numHits += 1;
        }
    }

    // Masked (todo: also include alpha-translucents here, but treat them like masked)
    {
        uint rayFlags = gl_RayFlagsNoOpaqueNV;
        uint cullMask = RT_HIT_MASK_MASKED;

        traceNV(topLevelAS, rayFlags, cullMask, 0, 0, 0, origin, tmin, direction, tmax, 0);
        if (payload.hitT != HIT_T_MISS) {
            tmax = payload.hitT;
            color = payload.color;
            numHits += 1;
        }
    }

    // Draw environment if miss
    if (numHits == 0) {
        // TODO: Consider if we really want to use the very large value camera.far here or if we should use some smaller "large" value for sky hits.
        // For the purpose of the Chebychev-test we do want to record a large variance of course, but we need some numerical stability still.. 
        // We should never need to see anything beyond the grid cell distance diagonal, so maybe just set it to that (plus epsilon)? Would that work?
        tmax = camera.far; // if miss, use camera far distance as hit distance

        vec2 sampleUv = sphericalUvFromDirection(direction);
        color = pushConstants.environmentMultiplier * texture(environmentMap, sampleUv).rgb;
    }

    HitResult result;
    result.color = color;
    result.dist = tmax;
    return result;
}

HitResult traceRayForProbe(uint probeIdx, uint sampleIdx, uint sampleCount)
{
    vec3 probePosition = calculateProbePosition(probeGridData, probeIdx);
    vec3 sampleDirection = calculateRotatedSphericalFibonacciSample(probeIdx, sampleIdx, sampleCount, pushConstants.frameIdx);
    HitResult result = tracePrimaryRay(probePosition, sampleDirection);
    return result;
}

/*
// TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
// TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
// TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
// TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO
vec3 evaluateIndirectLight(vec3 P, vec3 N, vec3 baseColor, float metallic, float roughness)
{
    // TODO: Use physically plausible amounts! For now we just use a silly estimate for F since we don't actually include glossy stuff at the moment.
    float a = square(roughness);
    float fakeF = pow(a, 5.0);

    vec3 irradiance = sampleDynamicDiffuseGlobalIllumination(P, N, probeGridData, probeIrradianceTex, probeVisibilityTex);
    vec3 indirectDiffuse = vec3(1.0 - metallic) * vec3(1.0 - fakeF) * baseColor * irradiance;

    return indirectDiffuse + indirectGlossy;
}
*/

void main()
{
    ivec2 targetPixel = ivec2(gl_LaunchIDNV.xy);

    // TODO: We're "supposed" to report *negative* ray distance when we hit a backface, so that we can optimize probe offsets! We're not doing that yet though.
    //    see gl_HitKindFrontFacingTriangleNV & gl_HitKindBackFacingTriangleNV

    uint probeIdx = gl_LaunchIDNV.x;
    uint sampleIdx = gl_LaunchIDNV.y;
    uint sampleCount = imageSize(surfelImage).y;
    HitResult probeSample = traceRayForProbe(probeIdx, sampleIdx, sampleCount);

    // TODO: Sample previous frame indirect for temporal multi-bounce!
    //probeSample.color += evaluateIndirectLight(hitPos, hitNormal, hitBaseColor, hitMetallic, hitRoughness);

    imageStore(surfelImage, targetPixel, vec4(probeSample.color, probeSample.dist));

    //////////////////////////

#if 0 // for debugging the ray tracing code and displaying it on a texture instead of rendering into the probes

    const vec2 pixelCenter = vec2(gl_LaunchIDNV.xy) + vec2(0.5);
    const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeNV.xy);
    vec2 d = inUV * 2.0 - 1.0;

    vec4 origin = camera.worldFromView * vec4(0, 0, 0, 1);
    vec4 target = camera.viewFromProjection * vec4(d.x, d.y, 1.0, 1.0);
    vec4 direction = camera.worldFromView * vec4(normalize(target.xyz / target.w), 0.0);

    HitResult result = tracePrimaryRay(origin.xyz, direction.xyz);
    imageStore(surfelImage, targetPixel, vec4(result.color, 0.0));

#endif
}
