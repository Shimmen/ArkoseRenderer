#version 460

#include <common.glsl>
#include <common/camera.glsl>
#include <common/namedUniforms.glsl>

layout(set = 0, binding = 0, r16f) uniform writeonly image2D circleOfConfusionImg;
layout(set = 0, binding = 1) uniform sampler2D sceneDepthTex;
layout(set = 0, binding = 2) uniform CameraStateBlock { CameraState camera; };

NAMED_UNIFORMS(constants,
    uvec2 targetSize;
    float focusDepth; // (m)
)


layout(local_size_x = 8, local_size_y = 8) in;
void main()
{
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    if (any(greaterThanEqual(pixelCoord, constants.targetSize)))
        return;

    float sceneDepthNonLinear = texelFetch(sceneDepthTex, pixelCoord, 0).r;
    float sceneDepth = calculateLinearDepth(sceneDepthNonLinear, camera);

    // Formula from Wikipedia: https://en.wikipedia.org/wiki/Circle_of_confusion#Determining_a_circle_of_confusion_diameter_from_the_object_field

    float S1 = constants.focusDepth;
    float S2 = sceneDepth;
    float f = camera.focalLength; // (m) (same as depth)
    float N = camera.aperture; // i.e. f-number

    float fac1 = abs(S2 - S1) / S2;
    float fac2 = square(f) / (N * (S1 - f));
    float coc = fac1 * fac2;

    // NOTE: Resulting CoC will be in (m) as all inputs are too, we will need to rescale to have it in pixels
    //       by dividing by the sensor size, or something similar (we need same aspect ratio as the screen!)

    imageStore(circleOfConfusionImg, pixelCoord, vec4(coc, 0.0, 0.0, 0.0));
}
